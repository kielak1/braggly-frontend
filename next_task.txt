
nalezy uzupelnic system o mozliwosc przesylania plików UXD na serwer backend. 
Przeslany plik powinien byc zapisywany  w systemie plikow (tutaj prosba o wskazanie jak to zrobic na serwisie railway, gdzie bedzie eksploatacja produkcyjna)
sygnatura pliku powinna byc zapamietywana w bazie danych i powinna zaweirac informacje:
    o uzytkowniu (id), ktory przeslal plik, 
    nazwe pod jaka plik zostanie zapisany w systemie plikowm 
    nazwe z jaka zostal przeslany, 
    nazwe nadana przez uzytkownika
    informacja z nagłowka pliku - ponizej przykladowy poczatek pliku:

    ; C:\DIFFDAT1\JKM\KKielak\Ibuprofen beta-CD\Ibuprofen.raw(Diffrac Plus V1.01 file) converted by XCH V1.0
_FILEVERSION=2
_SAMPLE='Ibuprofen'
_+SAMPLE='analiza jakosciowa (Vantec)'
_SITE='Warsaw'
_USER='National Institut of Public Health'
_SAMPLE_CHANGER_CODE=0
_ATTACHMENTS_CODE=0
_GONIOMETER_RADIUS=250.000000
_FIXED_DIVSLIT=1.200000
_FIXED_SAMPLESLIT=0.000000
_FIXED_DETSLIT=12.200000
_MONOCHROMATOR=0
; None
_SOLLER_SLITS_2='N'
_THIN_FILM='N'
_BETA_FILTER='N'
_FIXED_ANTISLIT=8.450000
_DATEMEASURED='16-Dec-2014 10:15:42'
_WL_UNIT='A'
_WL1=1.540600
_WL2=1.544390
_WL3=1.392220
_WLRATIO=0.500000
_ANODE='Cu'
; (Data for Range number 1)
_DRIVE='COUPLED'
_STEPTIME=110.400002
_STEPSIZE=0.007098
_STEPMODE='C'
_START=3.000000
_THETA=1.500000
_2THETA=3.000000
_KHI=0.000000
_PHI=0.000000
_X=0.000000
_Y=0.000000
_Z=0.000000
_DIVERGENCE=0.000000
_ANTISCATTER=0.499000
_DETECTOR=5
_HV=0.000000
_GAIN=0.000000
_LLD=0.000000
_ULD=0.000000
_DETECTORSLIT='unkn'
_AUX1=0.000000
_AUX2=0.000000
_AUX3=0.000000
_TIMESTARTED=8.000000
_TEMP_RATE=-1.000000
_TEMP_DELAY=-1.000000
_KV=40
_MA=40
_RANGE_WL=1.540600
_3DPLANE=0
_GONIOMETER=1.787900
_PSDCHANNEL0=0
_2THETACOUNTS
   3.0000      2164
   3.0071      2102
   3.0142      2061
   3.0213      2076
   3.0284      1955

   Jezeli plik nie bedzie zawieral nagłowka (lub jego czesci) a jedynie listę par wartoscoi to tez powinien zostac zaakceptowany

   informacja o pliku powinna zawierac pole czy dany plik moze byc udostepniany publicznie (domyslnie tak)

System powinien oferowac CRUD na tych plikach i ich sygnaturach.


Projektujac interfesj na frontendzie uzyj konwencji juz tam stosowanych. W szcegolnosci ponizszy kod potraktuj jako szablon dla ekranu wgyrwania pliku :

// src/app/user/uploads/page.tsx
"use client";

import { useState } from "react";
import { getCookie } from "@/utils/cookies";
import { useFetchTranslations } from "@/utils/fetchTranslations";
import "@/styles/globals.css";


const UploadUXD = () => {
  const [translations, setTranslations] = useState<Record<
    string,
    string
  > | null>(null);

  useFetchTranslations(setTranslations, getCookie);
  if (!translations) {
    return (
      <div className="max-w-4xl mx-auto p-6 text-center">
        <p className="text-gray-700">
          Ładowanie..
        </p>
      </div>
    );
  }
  return (
    <div className="max-w-4xl mx-auto p-6 bg-gray-100 rounded-lg shadow-md mt-6">
      <h1 className="text-3xl font-bold text-gray-800 mb-4">
        {translations.upload_uxd_files || "Upload XRD Files"}
      </h1>
      <div className="flex items-center space-x-4 mb-4"></div>{" "}
    </div>
  );
};

export default UploadUXD;


Projaktujac strukture danych na backend wez pod uwage isniejace definicje zwiazane z opisem uzytkonika.

package com.example.backend.model;

import io.swagger.v3.oas.annotations.media.Schema;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import jakarta.persistence.*;

import java.util.Collection;
import java.util.List;

@Entity
@Table(name = "users")
@Schema(description = "Model użytkownika systemu, który przechowuje dane logowania oraz role użytkownika")
public class User implements UserDetails {

    public enum Role {
        ADMIN, USER
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Schema(description = "Unikalny identyfikator użytkownika", example = "1")
    private Long id;

    @Column(unique = true, nullable = false)
    @Schema(description = "Unikalna nazwa użytkownika", example = "john_doe")
    private String username;

    @Column(nullable = false)
    @Schema(description = "Hasło użytkownika (przechowywane w formie zaszyfrowanej)", example = "$2a$10$...")
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    @Schema(description = "Rola użytkownika w systemie", example = "ADMIN")
    private Role role;

    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @Schema(description = "Obiekt przechowujący saldo kredytowe użytkownika")
    private UserCredits userCredits;

    public User() {
    }

    public User(String username, String password, Role role) {
        this.username = username;
        this.password = password;
        this.role = role;
        this.userCredits = new UserCredits(this, 0); // Automatyczne utworzenie powiązanego rekordu
    }

    @Schema(description = "Pobiera identyfikator użytkownika")
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    @Schema(description = "Pobiera rolę użytkownika")
    public Role getRole() {
        return role;
    }

    public void setRole(Role role) {
        this.role = role;
    }

    @Schema(description = "Pobiera saldo kredytowe użytkownika")
    public UserCredits getUserCredits() {
        return userCredits;
    }

    public void setUserCredits(UserCredits userCredits) {
        this.userCredits = userCredits;
        if (userCredits != null) {
            userCredits.setUser(this); // Synchronizacja referencji
        }
    }

    @Override
    @Schema(description = "Zwraca uprawnienia użytkownika", example = "[\"ROLE_ADMIN\"]")
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return List.of(new SimpleGrantedAuthority("ROLE_" + role.name()));
    }

    @Override
    @Schema(description = "Zwraca zaszyfrowane hasło użytkownika")
    public String getPassword() {
        return password;
    }

    @Override
    @Schema(description = "Zwraca nazwę użytkownika")
    public String getUsername() {
        return username;
    }

    @Override
    @Schema(description = "Czy konto użytkownika nie jest wygasłe?", example = "true")
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    @Schema(description = "Czy konto użytkownika nie jest zablokowane?", example = "true")
    public boolean isAccountNonLocked() {
        return true;
    }

    @Override
    @Schema(description = "Czy poświadczenia użytkownika nie wygasły?", example = "true")
    public boolean isCredentialsNonExpired() {
        return true;
    }

    @Override
    @Schema(description = "Czy użytkownik jest aktywny?", example = "true")
    public boolean isEnabled() {
        return true;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public void setUsername(String username) {
        this.username = username;
    }
}

struktura plikow na backend:

tree src
src
├── main
│   ├── java
│   │   └── com
│   │       └── example
│   │           └── backend
│   │               ├── BackendApplication.java
│   │               ├── config
│   │               │   ├── SecurityConfig.java
│   │               │   └── SwaggerConfig.java
│   │               ├── controller
│   │               │   ├── AdminController.java
│   │               │   ├── AuthController.java
│   │               │   ├── CreditController.java
│   │               │   ├── DebugController.java
│   │               │   ├── HelloController.java
│   │               │   ├── PaymentController.java
│   │               │   ├── WhoAmIController.java
│   │               │   └── XrdController.java
│   │               ├── model
│   │               │   ├── CreditPackage.java
│   │               │   ├── CreditPurchaseHistory.java
│   │               │   ├── CreditUsageHistory.java
│   │               │   ├── Peak.java
│   │               │   ├── UserCredits.java
│   │               │   ├── User.java
│   │               │   └── XrdData.java
│   │               ├── repository
│   │               │   ├── CreditPackageRepository.java
│   │               │   ├── CreditPurchaseHistoryRepository.java
│   │               │   ├── CreditUsageHistoryRepository.java
│   │               │   ├── UserCreditsRepository.java
│   │               │   └── UserRepository.java
│   │               ├── security
│   │               │   ├── JwtAuthenticationFilter.java
│   │               │   └── JwtUtil.java
│   │               └── service
│   │                   ├── CreditService.java
│   │                   ├── CustomUserDetailsService.java
│   │                   ├── UserService.java
│   │                   └── XrdService.java
│   └── resources
│       ├── application.properties
│       ├── static
│       └── templates
└── test
    └── java
        └── com
            └── example
                └── backend
                    ├── AuthenticationIntegrationTest.java
                    └── BackendApplicationTests.java


Na poczatek zaprojektuj struktury danych i api do zaladowania pliku
